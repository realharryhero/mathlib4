/-
Copyright (c) 2024 Jireh Loreaux. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jireh Loreaux
-/
import Mathlib.Algebra.Star.NonUnitalSubalgebra
import Mathlib.Analysis.NormedSpace.Spectrum
import Mathlib.Topology.ContinuousFunction.NonUnitalFunctionalCalculus
import Mathlib.Topology.ContinuousFunction.StoneWeierstrass

/-!
# Uniqueness of the continuous functional calculus

Let `s : Set ğ•œ` be compact where `ğ•œ` is either `â„` or `â„‚`. By the Stone-Weierstrass theorem, the
(star) subalgebra generated by polynomial functions on `s` is dense in `C(s, ğ•œ)`. Moreover, this
star subalgebra is generated by `X : ğ•œ[X]` (i.e., `ContinuousMap.restrict s (.id ğ•œ)`) alone.
Consequently, any continuous star `ğ•œ`-algebra homomorphism with domain `C(s, ğ•œ)`, is uniquely
determined by its value on `X : ğ•œ[X]`.

The same is true for `ğ•œ := â„â‰¥0`, so long as the algebra `A` is an `â„`-algebra, which we establish
by upgrading a map `C((s : Set â„â‰¥0), â„â‰¥0) â†’â‹†â‚[â„â‰¥0] A` to `C(((â†‘) '' s : Set â„), â„) â†’â‹†â‚[â„] A` in
the natural way, and then applying the uniqueness for `â„`-algebra homomorphisms.

This is the reason the `UniqueContinuousFunctionalCalculus` class exists in the first place, as
opposed to simply appealing directly to Stone-Weierstrass to prove `StarAlgHom.ext_continuousMap`.
-/

section Prereqs
-- all this section is done in other files, but I was lazy about using good imports
-- right now, this file is just a copy plus modifications of `Topology.ContinuousFunction.UniqueCFC`

open ContinuousMapZero

instance instSMulCommClass' {X R : Type*} [Zero X] [TopologicalSpace X]
    [CommSemiring R] [TopologicalSpace R] [TopologicalSemiring R] {M : Type*}
    [SMulZeroClass M R] [SMulCommClass M R R] [ContinuousConstSMul M R] :
    SMulCommClass M C(X, R)â‚€ C(X, R)â‚€ where
  smul_comm m f g := ext fun x â†¦ smul_comm m (f x) (g x)

instance instIsScalarTower' {X R : Type*} [Zero X] [TopologicalSpace X]
    [CommSemiring R] [TopologicalSpace R] [TopologicalSemiring R] {M : Type*}
    [SMulZeroClass M R] [IsScalarTower M R R] [ContinuousConstSMul M R] :
    IsScalarTower M C(X, R)â‚€ C(X, R)â‚€ where
  smul_assoc m f g := ext fun x â†¦ smul_assoc m (f x) (g x)

instance instStarModule {X R : Type*} [Zero X] [TopologicalSpace X]
    [CommSemiring R] [StarRing R] [TopologicalSpace R] [TopologicalSemiring R] {M : Type*}
    [SMulZeroClass M R] [ContinuousConstSMul M R] [Star M] [StarModule M R] [ContinuousStar R]:
    StarModule M C(X, R)â‚€ where
  star_smul r f := ext fun x â†¦ star_smul r (f x)

variable {ğ•œ : Type*} [RCLike ğ•œ]

@[simps!]
protected def ContinuousMapZero.id {s : Set ğ•œ} [Zero s] (h0 : ((0 : s) : ğ•œ) = 0) : C(s, ğ•œ)â‚€ :=
  âŸ¨.restrict s (.id ğ•œ), h0âŸ©

@[simp]
lemma ContinuousMapZero.toContinuousMap_id {s : Set ğ•œ} [Zero s] (h0 : ((0 : s) : ğ•œ) = 0) :
    (ContinuousMapZero.id h0 : C(s, ğ•œ)) = .restrict s (.id ğ•œ) :=
  rfl

open NonUnitalStarAlgebra in
lemma ContinuousMapZero.adjoin_id_dense {s : Set ğ•œ} [Zero s] (h0 : ((0 : s) : ğ•œ) = 0)
    [CompactSpace s] : Dense (adjoin ğ•œ {(.id h0 : C(s, ğ•œ)â‚€)} : Set C(s, ğ•œ)â‚€) := by
  sorry

namespace NonUnitalStarAlgebra
lemma adjoin_induction' {R A : Type*} [CommSemiring R] [NonUnitalSemiring A] [Module R A]
    [IsScalarTower R A A] [SMulCommClass R A A] [StarRing R] [StarRing A] [StarModule R A]
    {s : Set A} {p : âˆ€ x, x âˆˆ adjoin R s â†’ Prop} {a : A} (ha : a âˆˆ adjoin R s)
    (mem : âˆ€ (x : A) (hx : x âˆˆ s), p x (subset_adjoin R s hx))
    (add : âˆ€ x hx y hy, p x hx â†’ p y hy â†’ p (x + y) (add_mem hx hy))
    (zero : p 0 (zero_mem _))
    (mul : âˆ€ x hx y hy, p x hx â†’ p y hy â†’ p (x * y) (mul_mem hx hy))
    (smul : âˆ€ (r : R) x hx, p x hx â†’ p (r â€¢ x) (SMulMemClass.smul_mem r hx))
    (star : âˆ€ x hx, p x hx â†’ p (star x) (star_mem hx)) : p a ha :=
  sorry -- I'm lazy, and why don't we have this?
end NonUnitalStarAlgebra

instance quasispectrum.instCompactSpace {ğ•œ A : Type*} [NormedField ğ•œ] [NonUnitalNormedRing A]
    [NormedSpace ğ•œ A] [CompleteSpace A] [ProperSpace ğ•œ] [IsScalarTower ğ•œ A A] [SMulCommClass ğ•œ A A]
    (a : A) : CompactSpace (quasispectrum ğ•œ a) :=
  sorry

end Prereqs

section UniqueUnital

section RCLike

variable {ğ•œ A : Type*} [RCLike ğ•œ]

open NonUnitalStarAlgebra in
theorem RCLike.uniqueNonUnitalContinuousFunctionalCalculus_of_compactSpace_quasispectrum
    [TopologicalSpace A] [T2Space A] [NonUnitalRing A] [StarRing A] [Module ğ•œ A]
    [IsScalarTower ğ•œ A A] [SMulCommClass ğ•œ A A] [h : âˆ€ a : A, CompactSpace (quasispectrum ğ•œ a)] :
    UniqueNonUnitalContinuousFunctionalCalculus ğ•œ A where
  eq_of_continuous_of_map_id s hs _inst h0 Ï† Ïˆ hÏ† hÏˆ h := by
    rw [DFunLike.ext'_iff, â† Set.eqOn_univ, â† (ContinuousMapZero.adjoin_id_dense h0).closure_eq]
    refine Set.EqOn.closure (fun f hf â†¦ ?_) hÏ† hÏˆ
    rw [â† NonUnitalStarAlgHom.mem_equalizer]
    apply adjoin_le ?_ hf
    rw [Set.singleton_subset_iff]
    exact h
  compactSpace_quasispectrum := h

theorem RCLike.uniqueContinuousFunctionalCalculus_of_compactSpace_spectrum [TopologicalSpace A]
    [T2Space A] [Ring A] [StarRing A] [Algebra ğ•œ A] [h : âˆ€ a : A, CompactSpace (spectrum ğ•œ a)] :
    UniqueContinuousFunctionalCalculus ğ•œ A where
  eq_of_continuous_of_map_id s hs Ï† Ïˆ hÏ† hÏˆ h :=
    ContinuousMap.starAlgHom_ext_map_X hÏ† hÏˆ <| by
      convert h using 1
      all_goals exact congr_arg _ (by ext; simp)
  compactSpace_spectrum := h

instance RCLike.instUniqueNonUnitalContinuousFunctionalCalculus [NonUnitalNormedRing A]
    [StarRing A] [CompleteSpace A] [NormedSpace ğ•œ A] [IsScalarTower ğ•œ A A] [SMulCommClass ğ•œ A A] :
    UniqueNonUnitalContinuousFunctionalCalculus ğ•œ A :=
  RCLike.uniqueNonUnitalContinuousFunctionalCalculus_of_compactSpace_quasispectrum

instance RCLike.instUniqueContinuousFunctionalCalculus [NormedRing A] [StarRing A]
    [NormedAlgebra ğ•œ A] [CompleteSpace A] : UniqueContinuousFunctionalCalculus ğ•œ A :=
  RCLike.uniqueContinuousFunctionalCalculus_of_compactSpace_spectrum

end RCLike

section NNReal
open NNReal

variable {X : Type*} [TopologicalSpace X]

namespace ContinuousMap

/-- This map sends `f : C(X, â„)` to `Real.toNNReal âˆ˜ f`, bundled as a continuous map `C(X, â„â‰¥0)`. -/
@[pp_dot]
noncomputable def toNNReal (f : C(X, â„)) : C(X, â„â‰¥0) := .realToNNReal |>.comp f

@[fun_prop]
lemma continuous_toNNReal : Continuous (toNNReal (X := X)) := continuous_comp _

@[simp]
lemma toNNReal_apply (f : C(X, â„)) (x : X) : f.toNNReal x = (f x).toNNReal := rfl

lemma toNNReal_add_add_neg_add_neg_eq (f g : C(X, â„)) :
    (f + g).toNNReal + (-f).toNNReal + (-g).toNNReal =
      (-(f + g)).toNNReal + f.toNNReal + g.toNNReal := by
  ext x
  simp [max_neg_zero, -neg_add_rev]
  abel

lemma toNNReal_mul_add_neg_mul_add_mul_neg_eq (f g : C(X, â„)) :
    (f * g).toNNReal + (-f).toNNReal * g.toNNReal + f.toNNReal * (-g).toNNReal =
      (-(f * g)).toNNReal + f.toNNReal * g.toNNReal + (-f).toNNReal * (-g).toNNReal := by
  ext x
  simp [max_neg_zero, add_mul, mul_add]
  abel

@[simp]
lemma toNNReal_algebraMap (r : â„â‰¥0) :
    (algebraMap â„ C(X, â„) r).toNNReal = algebraMap â„â‰¥0 C(X, â„â‰¥0) r := by
  ext; simp

@[simp]
lemma toNNReal_neg_algebraMap (r : â„â‰¥0) : (- algebraMap â„ C(X, â„) r).toNNReal = 0 := by
  ext; simp

@[simp]
lemma toNNReal_one : (1 : C(X, â„)).toNNReal = 1 := toNNReal_algebraMap 1

@[simp]
lemma toNNReal_neg_one : (-1 : C(X, â„)).toNNReal = 0 := toNNReal_neg_algebraMap 1

end ContinuousMap

variable {A : Type*} [TopologicalSpace A] [Ring A] [StarRing A] [Algebra â„ A] [TopologicalRing A]

namespace StarAlgHom

/-- Given a star `â„â‰¥0`-algebra homomorphism `Ï†` from `C(X, â„â‰¥0)` into an `â„`-algebra `A`, this is
the unique extension of `Ï†` from `C(X, â„)` to `A` as a star `â„`-algebra homomorphism. -/
@[simps]
noncomputable def realContinuousMapOfNNReal (Ï† : C(X, â„â‰¥0) â†’â‹†â‚[â„â‰¥0] A) :
    C(X, â„) â†’â‹†â‚[â„] A where
  toFun f := Ï† f.toNNReal - Ï† (-f).toNNReal
  map_one' := by simp
  map_zero' := by simp
  map_mul' f g := by
    have := congr(Ï† $(f.toNNReal_mul_add_neg_mul_add_mul_neg_eq g))
    simp only [map_add, map_mul, sub_mul, mul_sub] at this âŠ¢
    rw [â† sub_eq_zero] at this âŠ¢
    convert this using 1
    abel
  map_add' f g := by
    have := congr(Ï† $(f.toNNReal_add_add_neg_add_neg_eq g))
    simp only [map_add] at this âŠ¢
    rw [â† sub_eq_zero] at this âŠ¢
    convert this using 1
    abel
  commutes' r := by
    simp only
    obtain (hr | hr) := le_total 0 r
    Â· lift r to â„â‰¥0 using hr
      simpa only [ContinuousMap.toNNReal_algebraMap, ContinuousMap.toNNReal_neg_algebraMap,
        map_zero, sub_zero] using AlgHomClass.commutes Ï† r
    Â· rw [â† neg_neg r, â† map_neg, neg_neg (-r)]
      rw [â† neg_nonneg] at hr
      lift -r to â„â‰¥0 using hr with r
      simpa only [map_neg, ContinuousMap.toNNReal_neg_algebraMap, map_zero,
        ContinuousMap.toNNReal_algebraMap, zero_sub, neg_inj] using AlgHomClass.commutes Ï† r
  map_star' f := by simp only [star_trivial, star_sub, â† map_star]

@[fun_prop]
lemma continuous_realContinuousMapOfNNReal (Ï† : C(X, â„â‰¥0) â†’â‹†â‚[â„â‰¥0] A)
    (hÏ† : Continuous Ï†) : Continuous Ï†.realContinuousMapOfNNReal := by
  simp [realContinuousMapOfNNReal]
  fun_prop

@[simp high]
lemma realContinuousMapOfNNReal_apply_comp_toReal (Ï† : C(X, â„â‰¥0) â†’â‹†â‚[â„â‰¥0] A)
    (f : C(X, â„â‰¥0)) :
    Ï†.realContinuousMapOfNNReal ((ContinuousMap.mk toReal continuous_coe).comp f) = Ï† f := by
  simp only [realContinuousMapOfNNReal_apply]
  convert_to Ï† f - Ï† 0 = Ï† f using 2
  on_goal -1 => rw [map_zero, sub_zero]
  all_goals
    congr
    ext x
    simp

lemma realContinuousMapOfNNReal_injective :
    Function.Injective (realContinuousMapOfNNReal (X := X) (A := A)) := by
  intro Ï† Ïˆ h
  ext f
  simpa using congr($(h) ((ContinuousMap.mk toReal continuous_coe).comp f))

end StarAlgHom

instance NNReal.instUniqueContinuousFunctionalCalculus [UniqueContinuousFunctionalCalculus â„ A] :
    UniqueContinuousFunctionalCalculus â„â‰¥0 A where
  compactSpace_spectrum a := by
    have : CompactSpace (spectrum â„ a) := UniqueContinuousFunctionalCalculus.compactSpace_spectrum a
    rw [â† isCompact_iff_compactSpace] at *
    rw [â† spectrum.preimage_algebraMap â„]
    exact closedEmbedding_subtype_val isClosed_nonneg |>.isCompact_preimage <| by assumption
  eq_of_continuous_of_map_id s hs Ï† Ïˆ hÏ† hÏˆ h := by
    let s' : Set â„ := (â†‘) '' s
    let e : s â‰ƒâ‚œ s' :=
      { toFun := Subtype.map (â†‘) (by simp [s'])
        invFun := Subtype.map Real.toNNReal (by simp [s'])
        left_inv := fun _ â†¦ by ext; simp
        right_inv := fun x â†¦ by
          ext
          obtain âŸ¨y, -, hyâŸ© := x.2
          simpa using hy â–¸ NNReal.coe_nonneg y
        continuous_toFun := continuous_coe.subtype_map (by simp [s'])
        continuous_invFun := continuous_real_toNNReal.subtype_map (by simp [s']) }
    have (Î¾ : C(s, â„â‰¥0) â†’â‹†â‚[â„â‰¥0] A) (hÎ¾ : Continuous Î¾) :
        (let Î¾' := Î¾.realContinuousMapOfNNReal.comp <| ContinuousMap.compStarAlgHom' â„ â„ e;
        Continuous Î¾' âˆ§ Î¾' (.restrict s' <| .id â„) = Î¾ (.restrict s <| .id â„â‰¥0)) := by
      intro Î¾'
      refine âŸ¨Î¾.continuous_realContinuousMapOfNNReal hÎ¾ |>.comp <|
        ContinuousMap.continuous_comp_left _, ?_âŸ©
      exact Î¾.realContinuousMapOfNNReal_apply_comp_toReal (.restrict s <| .id â„â‰¥0)
    obtain âŸ¨hÏ†', hÏ†_idâŸ© := this Ï† hÏ†
    obtain âŸ¨hÏˆ', hÏˆ_idâŸ© := this Ïˆ hÏˆ
    have hs' : CompactSpace s' := e.compactSpace
    have h' := UniqueContinuousFunctionalCalculus.eq_of_continuous_of_map_id s' _ _ hÏ†' hÏˆ'
      (hÏ†_id â–¸ hÏˆ_id â–¸ h)
    have h'' := congr($(h').comp <| ContinuousMap.compStarAlgHom' â„ â„ (e.symm : C(s', s)))
    have : (ContinuousMap.compStarAlgHom' â„ â„ (e : C(s, s'))).comp
        (ContinuousMap.compStarAlgHom' â„ â„ (e.symm : C(s', s))) = StarAlgHom.id _ _ := by
      ext1; simp
    simp only [StarAlgHom.comp_assoc, this, StarAlgHom.comp_id] at h''
    exact StarAlgHom.realContinuousMapOfNNReal_injective h''

end NNReal

end UniqueUnital
